import{t as e}from"./Stack-BtQgkU3W.js";import{Ft as t,Lt as n,_ as r,c as i,d as a,f as o,n as s,s as c,u as l,xt as u,y as d}from"./index-DjY4hVv8.js";var f=n(u(),1);function p({onGenerate:t,onApply:n,onClear:r,actionLoading:i}){return(0,f.jsxs)(o,{children:[(0,f.jsx)(a,{title:`Actions`}),(0,f.jsx)(e,{spacing:2,children:[{label:`Generate New Calibration`,description:`Analyze all files in library to generate optimal calibration values. This will scan the entire library and may take some time.`,onClick:t,color:`primary`,variant:`contained`},{label:`Apply Calibration to Library`,description:`Queue all files for reprocessing with current calibration. This will update all tags based on the current calibration values.`,onClick:n,color:`primary`,variant:`contained`},{label:`Clear Calibration Queue`,description:`Remove all pending calibration jobs from the queue. Running jobs will complete.`,onClick:r,color:`error`,variant:`outlined`}].map(e=>(0,f.jsx)(c,{label:e.label,description:e.description,onClick:e.onClick,disabled:i,variant:e.variant,color:e.color},e.label))})]})}function m({status:e}){let t=[{label:`Pending`,value:e.pending},{label:`Running`,value:e.running},{label:`Completed`,value:e.completed},{label:`Errors`,value:e.errors}];return(0,f.jsxs)(o,{children:[(0,f.jsx)(a,{title:`Calibration Queue Status`}),(0,f.jsx)(i,{minColumnWidth:150,children:t.map(e=>(0,f.jsx)(l,{label:e.label,value:e.value,valueVariant:`h5`,centered:!0},e.label))}),(0,f.jsx)(r,{sx:{mt:2},children:(0,f.jsxs)(d,{variant:`body1`,children:[`Worker:`,` `,(0,f.jsx)(d,{component:`span`,sx:{color:e.worker_alive?`success.main`:`error.main`,fontWeight:600},children:e.worker_alive?`Alive`:`Not Running`}),e.worker_alive&&(0,f.jsxs)(f.Fragment,{children:[` â€¢ `,(0,f.jsx)(d,{component:`span`,sx:{color:e.worker_busy?`info.main`:`success.main`,fontWeight:600},children:e.worker_busy?`Busy`:`Idle`})]})]})})]})}var h=n(t(),1);function g(){let[e,t]=(0,h.useState)(null),[n,r]=(0,h.useState)(!0),[i,a]=(0,h.useState)(null),[o,c]=(0,h.useState)(!1),l=async()=>{try{r(!0),a(null),t(await s.calibration.getStatus())}catch(e){a(e instanceof Error?e.message:`Failed to load status`),console.error(`[Calibration] Load error:`,e)}finally{r(!1)}};return(0,h.useEffect)(()=>{l()},[]),{status:e,loading:n,error:i,actionLoading:o,handleGenerate:async()=>{if(confirm(`Generate new calibration? This analyzes all library files.`))try{c(!0);let e=await s.calibration.generate(!0),t=Object.keys(e.data.calibrations||{}).length,n=e.saved_files?.saved_files||0,r=`Calibration generated!

`;r+=`Library size: ${e.data.library_size} files\n`,r+=`Calibrations generated: ${t}\n`,r+=`Tags skipped (insufficient data): ${e.data.skipped_tags}\n`,n>0&&(r+=`\nSaved ${n} calibration files`),alert(r)}catch(e){alert(e instanceof Error?e.message:`Failed to generate calibration`)}finally{c(!1)}},handleApply:async()=>{if(confirm(`Apply calibration to entire library? This will queue all files for reprocessing.`))try{c(!0);let e=await s.calibration.apply();alert(`Queued ${e.queued} files for recalibration`),await l()}catch(e){alert(e instanceof Error?e.message:`Failed to apply calibration`)}finally{c(!1)}},handleClear:async()=>{if(confirm(`Clear all calibration queue jobs?`))try{c(!0);let e=await s.calibration.clear();alert(`Cleared ${e.cleared} jobs`),await l()}catch(e){alert(e instanceof Error?e.message:`Failed to clear calibration queue`)}finally{c(!1)}}}}function _(){let{status:e,loading:t,error:n,actionLoading:r,handleGenerate:i,handleApply:a,handleClear:o}=g();return(0,f.jsxs)(`div`,{style:{padding:`20px`},children:[(0,f.jsx)(`h1`,{style:{marginBottom:`20px`},children:`Calibration`}),t&&(0,f.jsx)(`p`,{children:`Loading calibration status...`}),n&&(0,f.jsxs)(`p`,{style:{color:`var(--accent-red)`},children:[`Error: `,n]}),e&&(0,f.jsxs)(`div`,{style:{display:`grid`,gap:`20px`},children:[(0,f.jsx)(m,{status:e}),(0,f.jsx)(p,{onGenerate:i,onApply:a,onClear:o,actionLoading:r})]})]})}export{_ as CalibrationPage};