import{t as e}from"./Stack-CqnjfNxH.js";import{It as t,Rt as n,St as r,b as i,c as a,d as o,f as s,l as c,n as l,p as u,v as d}from"./index-Bmoj33p1.js";var f=n(r(),1);function p({onGenerate:t,onApply:n,onClear:r,actionLoading:i}){return(0,f.jsxs)(u,{children:[(0,f.jsx)(s,{title:`Actions`}),(0,f.jsx)(e,{spacing:2,children:[{label:`Generate New Calibration`,description:`Analyze all files in library to generate optimal calibration values. This will scan the entire library and may take some time.`,onClick:t,color:`primary`,variant:`contained`},{label:`Apply Calibration to Library`,description:`Queue all files for reprocessing with current calibration. This will update all tags based on the current calibration values.`,onClick:n,color:`primary`,variant:`contained`},{label:`Clear Calibration Queue`,description:`Remove all pending calibration jobs from the queue. Running jobs will complete.`,onClick:r,color:`error`,variant:`outlined`}].map(e=>(0,f.jsx)(a,{label:e.label,description:e.description,onClick:e.onClick,disabled:i,variant:e.variant,color:e.color},e.label))})]})}function m({status:e}){let t=[{label:`Pending`,value:e.pending},{label:`Running`,value:e.running},{label:`Completed`,value:e.completed},{label:`Errors`,value:e.errors}];return(0,f.jsxs)(u,{children:[(0,f.jsx)(s,{title:`Calibration Queue Status`}),(0,f.jsx)(c,{minColumnWidth:150,children:t.map(e=>(0,f.jsx)(o,{label:e.label,value:e.value,valueVariant:`h5`,centered:!0},e.label))}),(0,f.jsx)(d,{sx:{mt:2},children:(0,f.jsxs)(i,{variant:`body1`,children:[`Worker:`,` `,(0,f.jsx)(i,{component:`span`,sx:{color:e.worker_alive?`success.main`:`error.main`,fontWeight:600},children:e.worker_alive?`Alive`:`Not Running`}),e.worker_alive&&(0,f.jsxs)(f.Fragment,{children:[` â€¢ `,(0,f.jsx)(i,{component:`span`,sx:{color:e.worker_busy?`info.main`:`success.main`,fontWeight:600},children:e.worker_busy?`Busy`:`Idle`})]})]})})]})}var h=n(t(),1);function g(){let[e,t]=(0,h.useState)(null),[n,r]=(0,h.useState)(!0),[i,a]=(0,h.useState)(null),[o,s]=(0,h.useState)(!1),c=async()=>{try{r(!0),a(null),t(await l.calibration.getStatus())}catch(e){a(e instanceof Error?e.message:`Failed to load status`),console.error(`[Calibration] Load error:`,e)}finally{r(!1)}};return(0,h.useEffect)(()=>{c()},[]),{status:e,loading:n,error:i,actionLoading:o,handleGenerate:async()=>{if(confirm(`Generate new calibration? This analyzes all library files.`))try{s(!0);let e=await l.calibration.generate(!0),t=Object.keys(e.data.calibrations||{}).length,n=e.saved_files?.saved_files||0,r=`Calibration generated!

`;r+=`Library size: ${e.data.library_size} files\n`,r+=`Calibrations generated: ${t}\n`,r+=`Tags skipped (insufficient data): ${e.data.skipped_tags}\n`,n>0&&(r+=`\nSaved ${n} calibration files`),alert(r)}catch(e){alert(e instanceof Error?e.message:`Failed to generate calibration`)}finally{s(!1)}},handleApply:async()=>{if(confirm(`Apply calibration to entire library? This will queue all files for reprocessing.`))try{s(!0);let e=await l.calibration.apply();alert(`Queued ${e.queued} files for recalibration`),await c()}catch(e){alert(e instanceof Error?e.message:`Failed to apply calibration`)}finally{s(!1)}},handleClear:async()=>{if(confirm(`Clear all calibration queue jobs?`))try{s(!0);let e=await l.calibration.clear();alert(`Cleared ${e.cleared} jobs`),await c()}catch(e){alert(e instanceof Error?e.message:`Failed to clear calibration queue`)}finally{s(!1)}}}}function _(){let{status:e,loading:t,error:n,actionLoading:r,handleGenerate:i,handleApply:a,handleClear:o}=g();return(0,f.jsxs)(`div`,{style:{padding:`20px`},children:[(0,f.jsx)(`h1`,{style:{marginBottom:`20px`},children:`Calibration`}),t&&(0,f.jsx)(`p`,{children:`Loading calibration status...`}),n&&(0,f.jsxs)(`p`,{style:{color:`var(--accent-red)`},children:[`Error: `,n]}),e&&(0,f.jsxs)(`div`,{style:{display:`grid`,gap:`20px`},children:[(0,f.jsx)(m,{status:e}),(0,f.jsx)(p,{onGenerate:i,onApply:a,onClear:o,actionLoading:r})]})]})}export{_ as CalibrationPage};