import{a as e,c as t,i as n,l as r,s as i,u as a}from"./ui-DMTNeb6j.js";import{Z as o,dt as s,n as c,o as l,pt as u,s as d}from"./index-Ck38l4oW.js";var f=u(o(),1);function p({onGenerate:e,onApply:i,onClear:o,actionLoading:s}){return(0,f.jsxs)(r,{children:[(0,f.jsx)(t,{title:`Actions`}),(0,f.jsx)(a,{spacing:2,children:[{label:`Generate New Calibration`,description:`Analyze all files in library to generate optimal calibration values. This will scan the entire library and may take some time.`,onClick:e,color:`primary`,variant:`contained`},{label:`Apply Calibration to Library`,description:`Queue all files for reprocessing with current calibration. This will update all tags based on the current calibration values.`,onClick:i,color:`primary`,variant:`contained`},{label:`Clear Calibration Queue`,description:`Remove all pending calibration jobs from the queue. Running jobs will complete.`,onClick:o,color:`error`,variant:`outlined`}].map(e=>(0,f.jsx)(n,{label:e.label,description:e.description,onClick:e.onClick,disabled:s,variant:e.variant,color:e.color},e.label))})]})}function m({status:n}){let a=[{label:`Pending`,value:n.pending},{label:`Running`,value:n.running},{label:`Completed`,value:n.completed},{label:`Errors`,value:n.errors}];return(0,f.jsxs)(r,{children:[(0,f.jsx)(t,{title:`Calibration Queue Status`}),(0,f.jsx)(e,{minColumnWidth:150,children:a.map(e=>(0,f.jsx)(i,{label:e.label,value:e.value,valueVariant:`h5`,centered:!0},e.label))}),(0,f.jsx)(l,{sx:{mt:2},children:(0,f.jsxs)(d,{variant:`body1`,children:[`Worker:`,` `,(0,f.jsx)(d,{component:`span`,sx:{color:n.worker_alive?`success.main`:`error.main`,fontWeight:600},children:n.worker_alive?`Alive`:`Not Running`}),n.worker_alive&&(0,f.jsxs)(f.Fragment,{children:[` â€¢ `,(0,f.jsx)(d,{component:`span`,sx:{color:n.worker_busy?`info.main`:`success.main`,fontWeight:600},children:n.worker_busy?`Busy`:`Idle`})]})]})})]})}var h=u(s(),1);function g(){let[e,t]=(0,h.useState)(null),[n,r]=(0,h.useState)(!0),[i,a]=(0,h.useState)(null),[o,s]=(0,h.useState)(!1),l=async()=>{try{r(!0),a(null),t(await c.calibration.getStatus())}catch(e){a(e instanceof Error?e.message:`Failed to load status`),console.error(`[Calibration] Load error:`,e)}finally{r(!1)}};return(0,h.useEffect)(()=>{l()},[]),{status:e,loading:n,error:i,actionLoading:o,handleGenerate:async()=>{if(confirm(`Generate new calibration? This analyzes all library files.`))try{s(!0);let e=await c.calibration.generate(!0),t=Object.keys(e.data.calibrations||{}).length,n=e.saved_files?.saved_files||0,r=`Calibration generated!

`;r+=`Library size: ${e.data.library_size} files\n`,r+=`Calibrations generated: ${t}\n`,r+=`Tags skipped (insufficient data): ${e.data.skipped_tags}\n`,n>0&&(r+=`\nSaved ${n} calibration files`),alert(r)}catch(e){alert(e instanceof Error?e.message:`Failed to generate calibration`)}finally{s(!1)}},handleApply:async()=>{if(confirm(`Apply calibration to entire library? This will queue all files for reprocessing.`))try{s(!0);let e=await c.calibration.apply();alert(`Queued ${e.queued} files for recalibration`),await l()}catch(e){alert(e instanceof Error?e.message:`Failed to apply calibration`)}finally{s(!1)}},handleClear:async()=>{if(confirm(`Clear all calibration queue jobs?`))try{s(!0);let e=await c.calibration.clear();alert(`Cleared ${e.cleared} jobs`),await l()}catch(e){alert(e instanceof Error?e.message:`Failed to clear calibration queue`)}finally{s(!1)}}}}function _(){let{status:e,loading:t,error:n,actionLoading:r,handleGenerate:i,handleApply:a,handleClear:o}=g();return(0,f.jsxs)(`div`,{style:{padding:`20px`},children:[(0,f.jsx)(`h1`,{style:{marginBottom:`20px`},children:`Calibration`}),t&&(0,f.jsx)(`p`,{children:`Loading calibration status...`}),n&&(0,f.jsxs)(`p`,{style:{color:`var(--accent-red)`},children:[`Error: `,n]}),e&&(0,f.jsxs)(`div`,{style:{display:`grid`,gap:`20px`},children:[(0,f.jsx)(m,{status:e}),(0,f.jsx)(p,{onGenerate:i,onApply:a,onClear:o,actionLoading:r})]})]})}export{_ as CalibrationPage};