"""Entity operations for ArangoDB (artists, albums, labels, genres, years).

Entities are vertex collections for metadata with deterministic hash-based keys.
No normalization for equivalence - exact strings produce different entities.
"""

from typing import Any, cast

from arango.cursor import Cursor
from arango.database import StandardDatabase


class EntityOperations:
    """Operations for entity vertex collections (artists, albums, etc.)."""

    def __init__(self, db: StandardDatabase) -> None:
        self.db = db

    def count_orphaned_entities(self, collection: str) -> int:
        """Count entities in collection with no incoming edges.

        Args:
            collection: Entity collection name ("artists", "albums", etc.)

        Returns:
            Number of orphaned entities
        """
        cursor = cast(
            Cursor,
            self.db.aql.execute(
                """
                FOR entity IN @@collection
                    LET has_refs = (
                        FOR edge IN song_tag_edges
                            FILTER edge._from == entity._id
                            LIMIT 1
                            RETURN 1
                    )
                    FILTER LENGTH(has_refs) == 0
                    COLLECT WITH COUNT INTO total
                    RETURN total
                """,
                bind_vars={"@collection": collection},
            ),
        )
        return next(cursor, 0)

    def cleanup_orphaned_entities(self, collection: str) -> int:
        """Delete entities in collection with no incoming edges.

        Args:
            collection: Entity collection name ("artists", "albums", etc.)

        Returns:
            Number of entities deleted
        """
        cursor = cast(
            Cursor,
            self.db.aql.execute(
                """
                FOR entity IN @@collection
                    LET has_refs = (
                        FOR edge IN song_tag_edges
                            FILTER edge._from == entity._id
                            LIMIT 1
                            RETURN 1
                    )
                    FILTER LENGTH(has_refs) == 0
                    REMOVE entity IN @@collection
                    RETURN 1
                """,
                bind_vars={"@collection": collection},
            ),
        )
        return len(list(cursor))

    def upsert_entity(self, collection: str, entity_key: str, display_name: str) -> dict[str, Any]:
        """Get or create an entity and return its metadata.

        Entity _key is deterministic hash-based (generated by caller).
        If entity exists, returns existing entity without modification.
        If entity doesn't exist, creates with display_name.

        Args:
            collection: Entity collection name ("artists", "albums", etc.)
            entity_key: Deterministic _key (e.g., "v1_abc123...")
            display_name: Exact raw string for display

        Returns:
            Dict with '_id', '_key', 'display_name'
        """
        cursor = cast(
            Cursor,
            self.db.aql.execute(
                """
            UPSERT { _key: @entity_key }
            INSERT { _key: @entity_key, display_name: @display_name }
            UPDATE {}
            IN @@collection
            RETURN { _id: NEW._id, _key: NEW._key, display_name: NEW.display_name }
            """,
                bind_vars=cast(
                    dict[str, Any],
                    {
                        "@collection": collection,
                        "entity_key": entity_key,
                        "display_name": display_name,
                    },
                ),
            ),
        )
        result: dict[str, Any] | None = next(cursor, None)
        if not result:
            raise RuntimeError(f"Failed to upsert entity {collection}/{entity_key}")
        return result

    def get_entity(self, entity_id: str) -> dict[str, Any] | None:
        """Get entity details by _id.

        Args:
            entity_id: Document _id (e.g., "artists/v1_abc123...")

        Returns:
            Dict with '_id', '_key', 'display_name' or None
        """
        cursor = cast(
            Cursor,
            self.db.aql.execute(
                """
            RETURN DOCUMENT(@entity_id)
            """,
                bind_vars=cast(dict[str, Any], {"entity_id": entity_id}),
            ),
        )
        entity: dict[str, Any] | None = next(cursor, None)
        return entity

    def list_entities(
        self,
        collection: str,
        limit: int = 1000,
        offset: int = 0,
        search: str | None = None,
    ) -> list[dict[str, Any]]:
        """List entities from a collection.

        Args:
            collection: Entity collection name ("artists", "albums", etc.)
            limit: Maximum number of results
            offset: Skip first N results
            search: Optional case-insensitive substring search on display_name

        Returns:
            List of entity dicts with '_id', '_key', 'display_name'
        """
        cursor = cast(
            Cursor,
            self.db.aql.execute(
                """
            FOR entity IN @@collection
                FILTER @search == null OR CONTAINS(LOWER(entity.display_name), LOWER(@search))
                SORT entity.display_name
                LIMIT @offset, @limit
                RETURN {
                    _id: entity._id,
                    _key: entity._key,
                    display_name: entity.display_name
                }
            """,
                bind_vars=cast(
                    dict[str, Any],
                    {
                        "@collection": collection,
                        "search": search,
                        "limit": limit,
                        "offset": offset,
                    },
                ),
            ),
        )
        return list(cursor)

    def count_entities(self, collection: str, search: str | None = None) -> int:
        """Count entities in a collection.

        Args:
            collection: Entity collection name
            search: Optional case-insensitive substring search on display_name

        Returns:
            Total count
        """
        cursor = cast(
            Cursor,
            self.db.aql.execute(
                """
            FOR entity IN @@collection
                FILTER @search == null OR CONTAINS(LOWER(entity.display_name), LOWER(@search))
                COLLECT WITH COUNT INTO c
                RETURN c
            """,
                bind_vars=cast(
                    dict[str, Any],
                    {
                        "@collection": collection,
                        "search": search,
                    },
                ),
            ),
        )
        result = next(cursor, 0)
        return int(result)
