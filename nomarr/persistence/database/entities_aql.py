"""Entity operations for ArangoDB (artists, albums, labels, genres, years).

Entities are vertex collections for metadata with deterministic hash-based keys.
No normalization for equivalence - exact strings produce different entities.
"""

from typing import Any, cast

from arango.cursor import Cursor
from arango.database import StandardDatabase


class EntityOperations:
    """Operations for entity vertex collections (artists, albums, etc.)."""

    def __init__(self, db: StandardDatabase) -> None:
        self.db = db

    def upsert_entity(self, collection: str, entity_key: str, display_name: str) -> str:
        """Get or create an entity and return its _id.

        Entity _key is deterministic hash-based (generated by caller).
        If entity exists, returns existing _id without modification.
        If entity doesn't exist, creates with display_name.

        Args:
            collection: Entity collection name ("artists", "albums", etc.)
            entity_key: Deterministic _key (e.g., "v1_abc123...")
            display_name: Exact raw string for display

        Returns:
            Entity _id (e.g., "artists/v1_abc123...")
        """
        cursor = cast(
            Cursor,
            self.db.aql.execute(
                """
            UPSERT { _key: @entity_key }
            INSERT { _key: @entity_key, display_name: @display_name }
            UPDATE {}
            IN @@collection
            RETURN NEW._id
            """,
                bind_vars={
                    "@collection": collection,
                    "entity_key": entity_key,
                    "display_name": display_name,
                },
            ),
        )
        result = next(cursor, None)
        if not result:
            raise RuntimeError(f"Failed to upsert entity {collection}/{entity_key}")
        return str(result)

    def get_entity(self, collection: str, entity_id: str) -> dict[str, Any] | None:
        """Get entity details by _id.

        Args:
            collection: Entity collection name (unused but kept for API consistency)
            entity_id: Document _id (e.g., "artists/v1_abc123...")

        Returns:
            Dict with '_id', '_key', 'display_name' or None
        """
        cursor = cast(
            Cursor,
            self.db.aql.execute(
                """
            RETURN DOCUMENT(@entity_id)
            """,
                bind_vars={"entity_id": entity_id},
            ),
        )
        entity: dict[str, Any] | None = next(cursor, None)
        return entity

    def list_entities(
        self,
        collection: str,
        limit: int = 1000,
        offset: int = 0,
        search: str | None = None,
    ) -> list[dict[str, Any]]:
        """List entities from a collection.

        Args:
            collection: Entity collection name ("artists", "albums", etc.)
            limit: Maximum number of results
            offset: Skip first N results
            search: Optional case-insensitive substring search on display_name

        Returns:
            List of entity dicts with '_id', '_key', 'display_name'
        """
        # Build filter clause
        filter_clause = ""
        bind_vars_dict: dict[str, Any] = {
            "@collection": collection,
            "limit": limit,
            "offset": offset,
        }

        if search:
            filter_clause = "FILTER CONTAINS(LOWER(entity.display_name), LOWER(@search))"
            bind_vars_dict["search"] = search

        cursor = cast(
            Cursor,
            self.db.aql.execute(
                f"""
            FOR entity IN @@collection
                {filter_clause}
                SORT entity.display_name
                LIMIT @offset, @limit
                RETURN {{
                    _id: entity._id,
                    _key: entity._key,
                    display_name: entity.display_name
                }}
            """,
                bind_vars=cast(dict[str, Any], bind_vars_dict),
            ),
        )
        return list(cursor)

    def count_entities(self, collection: str, search: str | None = None) -> int:
        """Count entities in a collection.

        Args:
            collection: Entity collection name
            search: Optional case-insensitive substring search on display_name

        Returns:
            Total count
        """
        filter_clause = ""
        bind_vars_dict: dict[str, Any] = {"@collection": collection}

        if search:
            filter_clause = "FILTER CONTAINS(LOWER(entity.display_name), LOWER(@search))"
            bind_vars_dict["search"] = search

        cursor = cast(
            Cursor,
            self.db.aql.execute(
                f"""
            RETURN LENGTH(
                FOR entity IN @@collection
                    {filter_clause}
                    RETURN 1
            )
            """,
                bind_vars=cast(dict[str, Any], bind_vars_dict),
            ),
        )
        result = next(cursor, 0)
        return int(result)
